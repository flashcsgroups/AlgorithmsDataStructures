2. Сортировка Выбором (Selection Sort).
    /// Алгоритм:
    /// * На i-ой операции считаем элемент с текущим индексом минимальным и сравниваем с остальными.
    /// * Если найден минимальный, то текущему присваиваем найденный и меняем элементы местами.
    /// * Так, циклически проходим до конца структуры данных.
    
    /// Соблюдение инварианта (неизменяемость) базируется на 2 правилах:
    /// 1. То что слева  от текущего не должно меняться, т.к, отсортировано.
    /// 2. То что справа от текущего не может быть меньше левой части.
    
-- Наихудшая временная сложность алгоритма ~N^2/2. Вытекает из суммы ряда арифметической прогрессии по количеству сравнений.
-- Вот как это выглядит:(N-1)+(N-2)+...+ 1 + 0 = ~N^2/2.
   Максимальное количество обменов равно количеству элементов, т.е. N, т.е., число замен всегда линейно.
   Если построить табличку, то на каждой итерации уменьшается обработка на 1 элемент.
   Т.к., сортировка удовлетворяет правилам инварианта то, те элементы, которые уже обработаны не трогаются, не изменяются.
-- Квадратичное время не зависит от входных данных. Если у нас частично отсортированный массив, то алгоритм этого не учитывает.
-- Время выполнения растет от количества сравнений, т.е., от N.
-- На практике не используется, в основном, только в целях обучения.