1. Сортировка Пузырьком (Bubble Sort).
    /// Алгоритм:
    /// * Берем i-й элемент и сравниваем со всеми, начиная с i+1.
    /// * Если i > i+1, то меняем местами.
    /// * Так, циклически попарно сравниваем все элементы между собой.
    
-- На практике не используется, в основном, только в целях обучения.
-- Временная сложность алгоритма `N^2, т.е., квадратичное время увеличивается по мере роста числа элементов.
-- Из-за попарного сравнения неэффективен на больших массивах. Не используется на практике.

2. Сортировка Выбором (Selection Sort).
    /// Алгоритм:
    /// * На i-ой операции считаем элемент с текущим индексом минимальным и сравниваем с остальными.
    /// * Если найден минимальный, то текущему присваиваем найденный и меняем элементы местами.
    /// * Так, циклически проходим до конца структуры данных.
    
    /// Соблюдение инварианта (неизменяемость) базируется на 2 правилах:
    /// 1. То что слева  от текущего не должно меняться, т.к, отсортировано.
    /// 2. То что справа от текущего не может быть меньше левой части.
    
-- Наихудшая временная сложность алгоритма ~N^2/2. Вытекает из суммы ряда арифметической прогрессии по количеству сравнений.
-- Вот как это выглядит:(N-1)+(N-2)+...+ 1 + 0 = ~N^2/2.
   Максимальное количество обменов равно количеству элементов, т.е. N, т.е., число замен всегда линейно.
   Если построить табличку, то на каждой итерации уменьшается обработка на 1 элемент.
   Т.к., сортировка удовлетворяет правилам инварианта то, те элементы, которые уже обработаны не трогаются, не изменяются.
-- Квадратичное время не зависит от входных данных. Если у нас частично отсортированный массив, то алгоритм этого не учитывает.
-- Время выполнения растет от количества сравнений, т.е., от N.
-- На практике не используется, в основном, только в целях обучения.

3. Сортировка Вставкой (Insertion Sort).
    /// Алгоритм:
    /// * В начале цикла полагаем 1-й элемент первым в отсортированном подмассиве и шагаем с со 2-го.
    /// * Сравниваем элементы справа налево от текущего.
    /// * Если текуший меньше того, что слева из подмассива, то меняем местами.
    
    /// Соблюдение инварианта (неизменяемость) базируется на 2 правилах:
    /// 1. То что слева  от текущего находится в порядке возрастания.
    /// 2. То что справа от текущего еще не рассматривалось.
-- Наихудшая временная сложность алгоритма ~N^2/2 для сравнений и ~N^2/2 для обмена.
-- Если массив частично отсортирован, то количество обмена линеен, и в лучшем случае равен 0, а количество сравнений N-1.
   Т.е., в отличии от других массивов, включая быстрые, чем лучше отсортирован массив, тем быстрее работает алгоритм.
-- Понимая какие данные мы собираемся отсортировать, в некоторых случаях сортировка Вставкой дает лучшее результаты.
-- Соответственно, иногда может применяться на практике.

